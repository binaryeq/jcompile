package nz.ac.wgtn.shadedetector.jcompile.oracles;

import nz.ac.wgtn.shadedetector.jcompile.oracles.comparators.OpenJDKVersionsComparator;
import org.apache.commons.lang3.tuple.Pair;

import java.io.IOException;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

import static nz.ac.wgtn.shadedetector.jcompile.oracles.Utils.index;

/**
 * Construct a positive oracle for jars, i.e. sets of jars that originate from the same source code,
 * but are generated by different compilers.
 * @author jens dietrich
 */
public class SameArtifactDifferentCompilerJarOracle implements JarOracle {

    @Override
    public List<Pair<Path, Path>> build(Path jarFolder) throws IOException {

        Map<String,Set<Path>> jarsByArtifact = Utils.collectJarsByArtifact(jarFolder);
        List<Pair<Path, Path>> oracle = new ArrayList<>();
        OpenJDKVersionsComparator versionComparator = new OpenJDKVersionsComparator();

        for (String artifact:jarsByArtifact.keySet()) {
            Map<String, List<Path>> jarsGroupedByCompilerLineageSortedByCompilerVersion = jarsByArtifact.get(artifact).stream()
                .sorted((f1,f2) -> versionComparator.compare(Utils.COMPILER_USED.apply(f1),Utils.COMPILER_USED.apply(f2)))
                .collect(Collectors.groupingBy(f1 -> OpenJDKVersionsComparator.getLineageAndSemVer(Utils.COMPILER_USED.apply(f1))[0]));

            for (String lineage : jarsGroupedByCompilerLineageSortedByCompilerVersion.keySet()) {
                System.err.println("Processing lineage " + lineage + " for artifact " + artifact);      //DEBUG
                List<Path> jarsForLineage = jarsGroupedByCompilerLineageSortedByCompilerVersion.get(lineage);

                // instead of using all combinations, only use adjacent pairs from the same compiler lineage
                for (int i = 1; i < jarsForLineage.size(); i++) {
                    oracle.add(Pair.of(jarsForLineage.get(i - 1), jarsForLineage.get(i)));
                }
            }
        }

        return oracle;
    }

    // for testing TODO: remove
    public static void main (String[] args) throws IOException {
        Path jarFolder = Path.of(args[0]);
        List<Pair<Path, Path>> oracle = new SameArtifactDifferentCompilerJarOracle().build(jarFolder) ;
        for (Pair<Path, Path> pair:oracle) {
            System.out.println(pair.getLeft().toFile());
            System.out.println(pair.getRight().toFile());
            System.out.println();
        }
        System.out.println("oracle size: " + oracle.size());

    }

}
